Для реализации работы сразу с несколькими командами был придумал механизм разделения команд между собой с помощью специальных операторов называемых разделителями команд.\\ 
Стоит сразу же отметить, что разделители команд можно комбинировать в любом варианте, в любом количестве. 

\begin{important}
	Помните, что команды интерпретируются слева направо.
\end{important}

Рассмотрим следующие разделители команд:

\begin{myenv}{“;”}{разделитель для последовательного выполнения команд.}
\end{myenv}

\begin{shCode}{Например}
		ag@helios:/home/ag$ mkdir somedir ; ls -l ; touch somefile \end{shCode}

Последовательно выполнит команды, независимо от результата их выполнения.


\begin{myenv}{“|”}{разделитель для создания конвейера - неименованного канала канала между двумя
	командами. То есть выходной поток команды до предстоящей “|” будет направлен на
вход команде, стоящей после “|”.}
\end{myenv}

	\begin{shCode}{Например}
		ag@helios:/home/ag$ ls -l | wc;  \end{shCode}

	Подсчитает количество строк, слов, символов в выводе информации о содержимом домашнего каталога.

\textcolor{gray}{Момент, о котором часто забывают при работе с конвейером. Программы в нем запускаются и выполняются параллельно. Канал, это вещь без буфера, т.е. данные должны одновременно читаться и писаться. Это приводит к тому, что для каждой программы необходимо создавать свой процесс.}

~\\
\begin{myenv}{“\&”}{оператор, предназначенный для запуска команд в фоновом режиме, но может также использоваться как разделитель.}
\end{myenv}

	\begin{shCode}{Например}
		ag@helios:/home/ag$ find / -name somename & echo "Hello" \end{shCode}

Запустит команду find / -name somename в отдельнов фоновом процессе, а команда echo “Hello” будет запущена в обычном режиме и использует терминал (Выведет “Hello”).

~\\
Очень часто команды необходимо объединять разумно, то есть сложнее, чем способами описанными выше. Например, когда нам нужно, чтобы одна команда выполнилась только в случае успешного завершения другой команды. Это возможно с помощью операторов логической конъюнкции “И” и дизъюнкции “ИЛИ”.

\textcolor{gray}{Немного о том, как shell понимает, завершилась ли команда успешно. Для этого существует такое понятие как \textbf{код возврата} --- число характеризующие успешность выполнения команды.}

\textcolor{gray}{Код возврата успеха в shell, это всегда - 0. Если же команда завершилась неуспешно, мы можем посмотреть ее код возврата в переменной \$?, чтобы узнать более точную причину ошибки, а не просто факт ее возникновения.}


\begin{myenv}{“\&\&”}{разделитель “И”. Команда стоящая после “\&\&” выполнится только в случае успешного выполнения команды, стоящей до “\&\&”.}
\end{myenv}

\begin{shCode}{Например}
		ag@helios:/home/ag$ rm file1 && echo “Hello” \end{shCode}
“Hello“ будет выведено только в случае, если file1 был успешно удален.

\begin{myenv}{“||”}{разделитель “ИЛИ”. Команда стоящая после “||” выполнится только в случае
неуспешного выполнения команды, стоящей до “||”.}
\end{myenv}

\begin{shCode}{Например}
		ag@helios:/home/ag$ rm file1 || rm file2 && echo "Hello"  \end{shCode}
“Hello“ будет выведено только в случае, если был успешно удален хотя бы один из файлов file1, file2.
